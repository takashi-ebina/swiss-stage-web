# AI連携ガイドライン

**Version**: 1.0.0 | **最終更新**: 2025-12-31

このドキュメントは [constitution.md](constitution.md) の「原則III: AIペアプログラミング」の実践ガイドです。

---

## 基本方針

AIは**開発パートナー**として活用するが、**最終意思決定は人間が行う**。
AIの提案を盲目的に受け入れず、プロジェクトの原則・制約に照らして評価する。

---

## AIに実施させること（MUST）

### 1. 日本語での仕様書・ドキュメント記述

**対象ファイル:**
- `specs/[###-feature]/spec.md`
- `specs/[###-feature]/plan.md`
- `specs/[###-feature]/tasks.md`
- README、設計書全般

**要件:**
- 技術用語以外は日本語で記述
- コードコメントも日本語（変数名はローマ字可）
- Markdown形式で構造化

**プロンプト例:**
```
この機能の仕様書を日本語で作成してください。
以下を含めること：
- ユーザーストーリー（優先度付き）
- 受け入れテストシナリオ
- データモデル
```

---

### 2. 要件を満たすコード生成（TDD手順厳守）

**生成順序（厳守）:**

1. **テストコード生成**
   ```
   「[機能名]のJUnit5テストコードを作成してください。
   - テスト対象: src/domain/model/Tournament.java
   - カバー範囲: 対戦組合せロジック全パターン」
   ```

2. **テスト実行（Red確認）**
   ```
   「生成したテストを実行して、失敗することを確認してください」
   ```

3. **実装コード生成**
   ```
   「テストを通過する最小限の実装を生成してください」
   ```

4. **リファクタリング**
   ```
   「コードの重複を除去し、可読性を向上させてください」
   ```

**禁止事項:**
- テストなしでの実装コード生成
- 実装とテストの同時生成
- 「後でテストを書く」提案

---

### 3. DDD設計提案

**レイヤー分割チェックリスト（AI出力時に検証）:**

- [ ] `domain層`にビジネスロジックが集約されているか
- [ ] `infrastructure層`への依存が逆転していないか
- [ ] エンティティは不変性を保っているか
- [ ] リポジトリインターフェースが`domain層`に定義されているか

**プロンプト例:**
```
スイス方式トーナメントのマッチングロジックをDDDで設計してください。
以下の要件を満たすこと：
- ドメインモデル: Tournament, Participant, Match
- ドメインサービス: MatchingService
- リポジトリ: TournamentRepository (インターフェース)
- 値オブジェクト: Score, MatchResult
```

**AIの出力例（期待）:**
```java
// domain/model/Tournament.java
public class Tournament {
    private final TournamentId id;
    private final List<Participant> participants;
    
    // ドメインロジック
    public List<Match> generateNextRoundMatches() {
        // 勝ち点差0.5点以内のマッチング
    }
}
```

---

### 4. UIコンポーネントのライティング（Material-UI使用）

**生成要件:**
- Material-UI v5のコンポーネント使用
- TypeScriptの型定義を含む
- レスポンシブデザイン考慮（将来のP2対応準備）

**プロンプト例:**
```
対戦表入力画面のReactコンポーネントを作成してください。
使用ライブラリ: Material-UI v5
要件:
- TableコンポーネントでGrid表示
- 対戦結果入力用のSelect
- 保存ボタン（Buttonコンポーネント）
```

**生成禁止パターン:**
- Material-UI以外のUIライブラリ（Ant Design、Chakra UIなど）
- インラインスタイルの乱用（styled-componentsまたはMUI sx prop推奨）

---

## AIに実施させないこと（MUST NOT）

### 1. 技術スタック変更の独断決定

**禁止行為:**
- 「Spring BootではなくNest.jsが良い」提案
- 「DynamoDBではなくPostgreSQLを使うべき」提案
- 「ReactをVue.jsに変更しましょう」提案

**許可される提案:**
- 「現在のSpring Boot構成では〇〇の課題があります。解決策として△△を検討してはどうでしょうか？」（課金レベルが必要な場合は人間判断）

---

### 2. プロジェクト目的・方向性の変更提案

**禁止行為:**
- 「囲碁・将棋だけでなくポーカーにも対応しましょう」（スコープ外）
- 「課金機能を追加しましょう」（憲章の「やらないこと」に抵触）

**許可される相談:**
- 「将来的にチェスにも対応する可能性はありますか？その場合、今から〇〇を考慮すべきです」（意思決定は人間）

---

### 3. テスト省略の提案

**禁止行為:**
- 「簡単な機能なのでテストは不要です」
- 「プロトタイプなのでテストは後回しにしましょう」
- 「時間がないのでE2Eテストをスキップしましょう」

**例外:**
- 憲章原則IIに明記されたプロトタイプ検証時のみ、人間の明示的指示があればTDD省略可（ただし本実装時は必須）

---

### 4. セキュリティ要件の緩和

**禁止行為:**
- 「HTTPでも問題ありません」（HTTPS必須）
- 「入力検証は省略しましょう」（Bean Validation必須）
- 「JWTトークンの有効期限は1年にしましょう」（短期トークン原則）

---

## プロンプトテンプレート

### 機能実装時（TDD順守）

```
## フェーズ1: テスト作成
[機能名]のテストコードを作成してください。
憲章原則II（TDD）に従い、実装前にテストを書きます。

**対象:**
- ファイル: [ファイルパス]
- テストフレームワーク: [JUnit5/Jest]
- カバー範囲: [正常系/異常系/境界値]

**期待する出力:**
1. テストコードの全文
2. テスト実行コマンド
3. 失敗（Red）することの確認方法

---

## フェーズ2: 実装
上記テストを通過する最小限の実装を生成してください。

**制約:**
- DDDレイヤー構造に従う（application/domain/infrastructure/presentation）
- YAGNI原則（今必要でない機能は実装しない）

**期待する出力:**
1. 実装コードの全文
2. ビルド・実行コマンド
3. テスト成功（Green）の確認方法

---

## フェーズ3: リファクタリング
コードの重複除去・可読性向上を行ってください。
```

---

### 設計提案時

```
[機能名]の設計を提案してください。

**要件:**
- DDDレイヤー構造に従う
- 複数の設計オプションを提示（最低2案）
- 各オプションのトレードオフを明記

**提案フォーマット:**
### 案1: [設計名]
- メリット: ...
- デメリット: ...
- 複雑性の正当化: なぜシンプルな方法が不十分か

### 案2: [設計名]
（同様）

**推奨案**: [理由付き]
```

---

## AI出力の検証チェックリスト

実装前に以下を確認する：

### コード生成時
- [ ] 憲章の5原則に違反していないか
- [ ] DDDレイヤー構造が正しいか
- [ ] テストが先に書かれているか
- [ ] 技術スタック制約を守っているか
- [ ] 日本語コメントが含まれているか

### 設計提案時
- [ ] 複数案が提示されているか
- [ ] トレードオフが明記されているか
- [ ] 複雑な設計には正当化理由があるか
- [ ] 既存パターンとの整合性が取れているか

---

## トラブルシューティング

### Q: AIが技術スタック変更を提案してきた
**A:** 以下のように対応：
```
憲章の「技術スタック制約」セクションに従い、
[React/Spring Boot/DynamoDB]は変更不可です。
現在の技術スタック内での解決策を提案してください。
```

### Q: AIがテストなしで実装を提案してきた
**A:** 即座に修正を要求：
```
憲章原則II（TDD）に違反しています。
以下の順序で再生成してください：
1. テストコード作成
2. テスト実行（Red確認）
3. 実装コード作成
4. テスト成功（Green確認）
```

### Q: AIの提案が複雑すぎる
**A:** YAGNI原則を適用：
```
この設計は複雑すぎます。
憲章原則V「YAGNI原則」に従い、
よりシンプルな実装を提案してください。
複雑な実装が必要な場合、その正当化理由を明記してください。
```

---

## ペアプログラミングのベストプラクティス

### 1. スモールステップで進める
- 大きな機能を一度に依頼しない
- 「テスト → 実装 → リファクタリング」の単位で区切る

### 2. 明確な制約を伝える
```
【良い例】
「Tournament.javaにマッチング生成メソッドを追加してください。
制約: 
- 勝ち点差0.5点以内
- 未対戦者優先
- 32名以下のグループに対応」

【悪い例】
「マッチング機能を作ってください」
```

### 3. AIの出力を盲信しない
- 生成されたコードは必ずレビュー
- 憲章違反がないか検証
- 必要に応じて修正指示

### 4. コンテキストを共有する
- 関連する既存コードを提示
- プロジェクト固有の用語を説明
- 憲章の該当原則を引用

---

## 変更履歴

| バージョン | 日付 | 変更内容 |
|----------|------|---------|
| 1.0.0 | 2025-12-31 | 初版作成（憲章v1.0.0対応） |
